@use "sass:color";
@use "sass:math";

// =============================
// Info Bubble Component
// =============================
// A completely generic reusable floating container with an arrow pointer.
// Can be positioned on any of the 4 sides (top/bottom/left/right).
// Use this for tooltips, dropdowns, popovers, or any floating UI.
//
// This component is COMPLETELY ISOLATED and knows NOTHING about:
// - Dropdowns, menus, or lists
// - Specific content types
// - Application-specific styling
//
// Structure:
//   .bubble-wrapper (positioning container)
//     .bubble-container (visual container with arrow, border, background)
//       .bubble-header (optional header section)
//       .bubble-body (main content area)
//
// Goals:
// - Fully reusable across ANY UI pattern
// - Complete separation: structure | positioning | theming
// - Side-aware arrow rendering (top/bottom/left/right)
// - Named-argument API via $config map

// Arrow Configuration Guide
// -------------------------
// The arrow is rendered via :before (border) and :after (fill) pseudo-elements.
// Configure through mixin parameters only; avoid direct :before/:after overrides.
//
// Key parameters:
//   arrowSide: 'top' | 'bottom' | 'left' | 'right' - which side the arrow points FROM
//   arrowCrossEdge: 'top'|'bottom'|'left'|'right' - which edge to position along
//   arrowCrossOffset: distance from the cross edge (e.g., 12px from top)
//   arrowMainOffset: distance from main side; negative = overlap border (e.g., -2px)
//   arrowOuterSize: outer triangle (x y) for border (e.g., 9px 9px)
//   arrowInnerSize: inner triangle (x y) for fill (e.g., 9px 9px)
//   bubbleOverflow: 'visible' if arrow protrudes outside container
//
// Usage example (arrow on top, pointing down at trigger):
//   @include infoBubblePlacement((
//     rightOffset: 0px,
//     topOffset: 32px
//   ));
//   @include infoBubbleStructure((
//     bubbleOverflow: visible,
//     arrowSide: 'top',
//     arrowCrossEdge: 'right',
//     arrowCrossOffset: 12px,
//     arrowMainOffset: -2px
//   ));
//   @include infoBubbleTheme((
//     arrowSide: 'top',
//     surfaceBg: #333,
//     surfaceFg: #fff
//   ));

// 1) Bubble Placement - Position the wrapper relative to anchor
// --------------------------------------------------------------
@mixin infoBubblePlacement($config: ()) {
    $defaults: (
        rightOffset: 1px,
        topOffset: 37px,
        bottomOffset: 37px,
        zIndex: 999
    );

    $s: map-merge($defaults, $config);

    .bubble-wrapper {
        position: absolute;
        right: map-get($s, rightOffset);
        z-index: map-get($s, zIndex);

        &.render-position-top {
            bottom: map-get($s, bottomOffset);
        }

        &.render-position-bottom {
            top: map-get($s, topOffset);
        }
    }
}

// 2) Bubble Structure - Container shape, sizing, and arrow scaffolding
// ---------------------------------------------------------------------
@mixin infoBubbleStructure($config: ()) {
    $defaults: (
        bubbleRadius: 4px,
        bubbleOverflow: hidden,
        // Arrow configuration (side-aware)
        arrowSide: 'top',            // 'top' | 'bottom' | 'left' | 'right'
        arrowCrossEdge: null,        // auto: top/bottom -> 'right', left/right -> 'top'
        arrowCrossOffset: 8px,       // distance from the chosen cross edge
        arrowMainOffset: null,       // auto: protrude by outer triangle size along main side
        arrowOuterSize: 9px 9px,     // x y (outer triangle for border)
        arrowInnerSize: 9px 9px,     // x y (inner triangle for fill)
        arrowInnerMainOffset: null,  // auto from inner size
        arrowInnerMainAdjust: 0px,   // fine-tune inset of inner arrow along main side
        arrowInnerCrossAdjust: null, // fine-tune centering of inner vs outer along cross-axis
        arrowOuterMarginAdjust: 0px
    );
    $s: map-merge($defaults, $config);

    .bubble-container {
        width: 100%;
        white-space: nowrap;
        padding: 0;
        overflow: map-get($s, bubbleOverflow);
        border-radius: map-get($s, bubbleRadius);
        margin: 0;
        user-select: none;

        // Arrow scaffolding - theme will color these
        $side: map-get($s, arrowSide);
        $crossEdgeProvided: map-get($s, arrowCrossEdge);
        $crossOffset: map-get($s, arrowCrossOffset);
        $outerX: nth(map-get($s, arrowOuterSize), 1);
        $outerY: nth(map-get($s, arrowOuterSize), 2);
        $innerX: nth(map-get($s, arrowInnerSize), 1);
        $innerY: nth(map-get($s, arrowInnerSize), 2);

        // Auto compute defaults
        $crossEdge: if($crossEdgeProvided != null,
            $crossEdgeProvided,
            if($side == 'left' or $side == 'right', 'top', 'right')
        );
        $mainOffsetProvided: map-get($s, arrowMainOffset);
        $mainOffset: if($mainOffsetProvided != null, $mainOffsetProvided, -$outerY);

        &:before,
        &:after {
            content: "";
            position: absolute;
            z-index: 99;

            // place along the cross edge
            #{$crossEdge}: $crossOffset;
        }

        // Outer arrow (border)
        &:before {
            border-style: solid;
            margin-top: if($side == 'top' or $side == 'bottom', map-get($s, arrowOuterMarginAdjust), 0);
            margin-left: if($side == 'left' or $side == 'right', map-get($s, arrowOuterMarginAdjust), 0);

            // main side offset for OUTER (border) arrow
            @if $side == 'top' { top: $mainOffset; }
            @else if $side == 'bottom' { bottom: $mainOffset; }
            @else if $side == 'left' { left: $mainOffset; }
            @else if $side == 'right' { right: $mainOffset; }

            @if $side == 'top' {
                border-width: 0 map-get($s, arrowOuterSize);
            } @else if $side == 'bottom' {
                border-width: nth(map-get($s, arrowOuterSize), 2) nth(map-get($s, arrowOuterSize), 1) 0;
            } @else if $side == 'left' {
                border-width: nth(map-get($s, arrowOuterSize), 1) nth(map-get($s, arrowOuterSize), 2) nth(map-get($s, arrowOuterSize), 1) 0;
            } @else if $side == 'right' {
                border-width: nth(map-get($s, arrowOuterSize), 1) 0 nth(map-get($s, arrowOuterSize), 1) nth(map-get($s, arrowOuterSize), 2);
            }
        }

        // Inner arrow (fill)
        &:after {
            border-style: solid;

            // Inner (fill) arrow needs to be inset by 2px from outer to create border effect
            $innerProvided: map-get($s, arrowInnerMainOffset);
            $innerMainOffset: if($innerProvided != null, $innerProvided, -$innerY + 2px + map-get($s, arrowInnerMainAdjust));

            // Cross-axis centering: shift inner by half the width difference
            $crossProvided: map-get($s, arrowInnerCrossAdjust);
            $crossAuto: $outerX - $innerX;
            $crossAdjust: if($crossProvided != null, $crossProvided, $crossAuto);

            @if $side == 'top' { top: $innerMainOffset; }
            @else if $side == 'bottom' { bottom: $innerMainOffset; }
            @else if $side == 'left' { left: $innerMainOffset; }
            @else if $side == 'right' { right: $innerMainOffset; }

            // Apply cross-axis adjustment based on the chosen cross edge
            @if $crossEdge == 'top' { top: $crossOffset + $crossAdjust; }
            @else if $crossEdge == 'bottom' { bottom: $crossOffset + $crossAdjust; }
            @else if $crossEdge == 'left' { left: $crossOffset + $crossAdjust; }
            @else if $crossEdge == 'right' { right: $crossOffset + $crossAdjust; }

            @if $side == 'top' {
                border-width: 0 map-get($s, arrowInnerSize);
            } @else if $side == 'bottom' {
                border-width: nth(map-get($s, arrowInnerSize), 2) nth(map-get($s, arrowInnerSize), 1) 0;
            } @else if $side == 'left' {
                border-width: nth(map-get($s, arrowInnerSize), 1) nth(map-get($s, arrowInnerSize), 2) nth(map-get($s, arrowInnerSize), 1) 0;
            } @else if $side == 'right' {
                border-width: nth(map-get($s, arrowInnerSize), 1) 0 nth(map-get($s, arrowInnerSize), 1) nth(map-get($s, arrowInnerSize), 2);
            }
        }

        // Ensure header/body visually conform to bubble radius when overflow is visible
        .bubble-header:first-child {
            border-top-left-radius: map-get($s, bubbleRadius);
            border-top-right-radius: map-get($s, bubbleRadius);
        }

        .bubble-body:last-child {
            border-bottom-left-radius: map-get($s, bubbleRadius);
            border-bottom-right-radius: map-get($s, bubbleRadius);
        }

        // When both header and body exist
        &:has(.bubble-header) {
            .bubble-body {
                border-top-left-radius: 0;
                border-top-right-radius: 0;
            }
        }
    }
}

// 3) Bubble Theme - All colors, shadows, and visual treatments
// --------------------------------------------------------------
@mixin infoBubbleTheme($config: ()) {
    $defaults: (
        surfaceBg: #fff,               // bubble background
        surfaceFg: #333,               // bubble text color
        bubbleRadius: 4px,             // keep in sync with structure
        bubbleShadow: 0.05rem 0.05rem 7px 0px rgba(0,0,0,0.2),
        borderLightnessAdjustment: -10%,
        arrowSide: 'top'               // must match structure arrowSide
    );
    $s: map-merge($defaults, $config);

    .bubble-container {
        background: map-get($s, surfaceBg);
        color: map-get($s, surfaceFg);
        border: .06rem solid color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment));

        $arrowSide: map-get($s, arrowSide);

        // Color the correct arrow side based on arrowSide parameter
        @if $arrowSide == 'top' {
            &:before { border-color: transparent transparent color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment)); }
            &:after { border-color: transparent transparent map-get($s, surfaceBg); }
        } @else if $arrowSide == 'bottom' {
            &:before { border-color: color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment)) transparent transparent transparent; }
            &:after { border-color: map-get($s, surfaceBg) transparent transparent transparent; }
        } @else if $arrowSide == 'left' {
            &:before { border-color: transparent color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment)) transparent transparent; }
            &:after { border-color: transparent map-get($s, surfaceBg) transparent transparent; }
        } @else if $arrowSide == 'right' {
            &:before { border-color: transparent transparent transparent color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment)); }
            &:after { border-color: transparent transparent transparent map-get($s, surfaceBg); }
        }

        // Optional header section
        .bubble-header {
            background: color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment));
            border-top-left-radius: map-get($s, bubbleRadius);
            border-top-right-radius: map-get($s, bubbleRadius);
        }

        // Optional body section
        .bubble-body {
            background: map-get($s, surfaceBg);
        }
    }

    .bubble-wrapper {
        box-shadow: map-get($s, bubbleShadow);
    }
}

// Convenience one-shot mixin for quick setup
// -------------------------------------------
@mixin infoBubble($config: ()) {
    @include infoBubblePlacement($config);
    @include infoBubbleStructure($config);
    @include infoBubbleTheme($config);
}

// =============================
// Info Bubble Component
// =============================
// A reusable floating container with an arrow pointer that can be positioned
// on any of the 4 sides (top/bottom/left/right). Use this for tooltips,
// dropdowns, popovers, or any UI that needs to "point" to its trigger.
//
// Goals:
// - Fully reusable across different UI patterns
// - Complete separation: structure | positioning | theming
// - Side-aware arrow rendering (top/bottom/left/right)
// - Support for optional header sections
// - Named-argument API via $config map

// Arrow Configuration Guide
// -------------------------
// The arrow is rendered via :before (border) and :after (fill) pseudo-elements.
// Configure through mixin parameters only; avoid direct :before/:after overrides.
//
// Key parameters:
//   arrowSide: 'top' | 'bottom' | 'left' | 'right' - which side the arrow points FROM
//   arrowCrossEdge: 'top'|'bottom'|'left'|'right' - which edge to position along
//   arrowCrossOffset: distance from the cross edge (e.g., 12px from top)
//   arrowMainOffset: distance from main side; negative = overlap border (e.g., -2px)
//   arrowOuterSize: outer triangle (x y) for border (e.g., 9px 9px)
//   arrowInnerSize: inner triangle (x y) for fill (e.g., 9px 9px)
//   bubbleOverflow: 'visible' if arrow protrudes outside container
//
// Usage example (arrow on top, pointing down at trigger):
//   @include infoBubblePlacement((
//     rightOffset: 0px,
//     topOffset: 32px
//   ));
//   @include infoBubbleStructure((
//     bubbleOverflow: visible,
//     arrowSide: 'top',
//     arrowCrossEdge: 'right',
//     arrowCrossOffset: 12px,
//     arrowMainOffset: -2px
//   ));
//   @include infoBubbleTheme((
//     arrowSide: 'top',
//     surfaceBg: #333,
//     surfaceFg: #fff
//   ));

// 1) Bubble Placement - Position the wrapper relative to anchor
// --------------------------------------------------------------
@mixin infoBubblePlacement($config: ()) {
    $defaults: (
        rightOffset: 1px,
        topOffset: 37px,
        bottomOffset: 37px,
        zIndex: 999
    );

    $s: map-merge($defaults, $config);

    .bubble-wrapper {
        position: absolute;
        right: map-get($s, rightOffset);
        z-index: map-get($s, zIndex);

        &.render-position-top {
            bottom: map-get($s, bottomOffset);
        }

        &.render-position-bottom {
            top: map-get($s, topOffset);
        }
    }
}

// 2) Bubble Structure - Container shape, sizing, and arrow scaffolding
// ---------------------------------------------------------------------
@mixin infoBubbleStructure($config: ()) {
    $defaults: (
        bubbleRadius: 4px,
        bubbleOverflow: hidden,
        // Arrow configuration (side-aware)
        arrowSide: 'top',            // 'top' | 'bottom' | 'left' | 'right'
        arrowCrossEdge: null,        // auto: top/bottom -> 'right', left/right -> 'top'
        arrowCrossOffset: 8px,       // distance from the chosen cross edge
        arrowMainOffset: null,       // auto: protrude by outer triangle size along main side
        arrowOuterSize: 9px 9px,     // x y (outer triangle for border)
        arrowInnerSize: 9px 9px,     // x y (inner triangle for fill)
        arrowInnerMainOffset: null,  // auto from inner size
        arrowInnerMainAdjust: 0px,   // fine-tune inset of inner arrow along main side
        arrowInnerCrossAdjust: null, // fine-tune centering of inner vs outer along cross-axis
        arrowOuterMarginAdjust: 0px
    );
    $s: map-merge($defaults, $config);

    .bubble-container {
        width: 100%;
        white-space: nowrap;
        padding: 0;
        overflow: map-get($s, bubbleOverflow);
        border-radius: map-get($s, bubbleRadius);
        margin: 0;
        user-select: none;

        // Arrow scaffolding - theme will color these
        $side: map-get($s, arrowSide);
        $crossEdgeProvided: map-get($s, arrowCrossEdge);
        $crossOffset: map-get($s, arrowCrossOffset);
        $outerX: nth(map-get($s, arrowOuterSize), 1);
        $outerY: nth(map-get($s, arrowOuterSize), 2);
        $innerX: nth(map-get($s, arrowInnerSize), 1);
        $innerY: nth(map-get($s, arrowInnerSize), 2);

        // Auto compute defaults
        $crossEdge: if($crossEdgeProvided != null,
            $crossEdgeProvided,
            if($side == 'left' or $side == 'right', 'top', 'right')
        );
        $mainOffsetProvided: map-get($s, arrowMainOffset);
        $mainOffset: if($mainOffsetProvided != null, $mainOffsetProvided, -$outerY);

        &:before,
        &:after,
        .bubble-body:first-of-type:after {
            content: "";
            position: absolute;
            z-index: 99;

            // place along the cross edge
            #{$crossEdge}: $crossOffset;
        }

        // Outer arrow (border)
        &:before {
            border-style: solid;
            margin-top: if($side == 'top' or $side == 'bottom', map-get($s, arrowOuterMarginAdjust), 0);
            margin-left: if($side == 'left' or $side == 'right', map-get($s, arrowOuterMarginAdjust), 0);

            // main side offset for OUTER (border) arrow
            @if $side == 'top' { top: $mainOffset; }
            @else if $side == 'bottom' { bottom: $mainOffset; }
            @else if $side == 'left' { left: $mainOffset; }
            @else if $side == 'right' { right: $mainOffset; }

            @if $side == 'top' {
                border-width: 0 map-get($s, arrowOuterSize);
            } @else if $side == 'bottom' {
                border-width: nth(map-get($s, arrowOuterSize), 2) nth(map-get($s, arrowOuterSize), 1) 0;
            } @else if $side == 'left' {
                border-width: nth(map-get($s, arrowOuterSize), 1) nth(map-get($s, arrowOuterSize), 2) nth(map-get($s, arrowOuterSize), 1) 0;
            } @else if $side == 'right' {
                border-width: nth(map-get($s, arrowOuterSize), 1) 0 nth(map-get($s, arrowOuterSize), 1) nth(map-get($s, arrowOuterSize), 2);
            }
        }

        // Inner arrow (fill)
        &:after,
        .bubble-body:first-of-type:after {
            border-style: solid;

            // Inner (fill) arrow needs to be inset by 2px from outer to create border effect
            $innerProvided: map-get($s, arrowInnerMainOffset);
            $innerMainOffset: if($innerProvided != null, $innerProvided, -$innerY + 2px + map-get($s, arrowInnerMainAdjust));

            // Cross-axis centering: shift inner by half the width difference
            $crossProvided: map-get($s, arrowInnerCrossAdjust);
            $crossAuto: $outerX - $innerX;
            $crossAdjust: if($crossProvided != null, $crossProvided, $crossAuto);

            @if $side == 'top' { top: $innerMainOffset; }
            @else if $side == 'bottom' { bottom: $innerMainOffset; }
            @else if $side == 'left' { left: $innerMainOffset; }
            @else if $side == 'right' { right: $innerMainOffset; }

            // Apply cross-axis adjustment based on the chosen cross edge
            @if $crossEdge == 'top' { top: $crossOffset + $crossAdjust; }
            @else if $crossEdge == 'bottom' { bottom: $crossOffset + $crossAdjust; }
            @else if $crossEdge == 'left' { left: $crossOffset + $crossAdjust; }
            @else if $crossEdge == 'right' { right: $crossOffset + $crossAdjust; }

            @if $side == 'top' {
                border-width: 0 map-get($s, arrowInnerSize);
            } @else if $side == 'bottom' {
                border-width: nth(map-get($s, arrowInnerSize), 2) nth(map-get($s, arrowInnerSize), 1) 0;
            } @else if $side == 'left' {
                border-width: nth(map-get($s, arrowInnerSize), 1) nth(map-get($s, arrowInnerSize), 2) nth(map-get($s, arrowInnerSize), 1) 0;
            } @else if $side == 'right' {
                border-width: nth(map-get($s, arrowInnerSize), 1) 0 nth(map-get($s, arrowInnerSize), 1) nth(map-get($s, arrowInnerSize), 2);
            }
        }

        .bubble-body:first-of-type:hover:after {
            z-index: 999;
        }

        // Header section (optional, placed before body)
        .bubble-header {
            padding: .5rem .5rem;
            border-top-left-radius: map-get($s, bubbleRadius);
            border-top-right-radius: map-get($s, bubbleRadius);
        }

        // Body section contains main content
        .bubble-body {
            // When bubble has header, body should not have top rounding
            .bubble-header + & {
                border-top-left-radius: 0;
                border-top-right-radius: 0;
            }

            // When bubble has no header, body should have top rounding
            &:first-child {
                border-top-left-radius: map-get($s, bubbleRadius);
                border-top-right-radius: map-get($s, bubbleRadius);
            }

            // Body always has bottom rounding
            &:last-child {
                border-bottom-left-radius: map-get($s, bubbleRadius);
                border-bottom-right-radius: map-get($s, bubbleRadius);
            }
        }
    }
}

// 3) Bubble Theme - All colors, shadows, and visual treatments
// --------------------------------------------------------------
@mixin infoBubbleTheme($config: ()) {
    $defaults: (
        surfaceBg: #fff,               // bubble background
        surfaceFg: #333,               // bubble text color
        bubbleRadius: 4px,             // keep in sync with structure
        bubbleShadow: 0.05rem 0.05rem 7px 0px rgba(0,0,0,0.2),
        borderLightnessAdjustment: -10%,
        hoverLightnessAdjustment: -6%,
        arrowSide: 'top',              // must match structure arrowSide
        itemFontSize: .9rem            // needed for header meta sizing
    );
    $s: map-merge($defaults, $config);

    .bubble-wrapper {
        box-shadow: map-get($s, bubbleShadow);
    }

    .bubble-container {
        background: map-get($s, surfaceBg);
        color: map-get($s, surfaceFg);
        border: .06rem solid color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment));

        $arrowSide: map-get($s, arrowSide);

        // Color the correct arrow side based on arrowSide parameter
        @if $arrowSide == 'top' {
            &:before { border-color: transparent transparent color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment)); }
            &:after, .bubble-body:first-of-type:after { border-color: transparent transparent map-get($s, surfaceBg); }
        } @else if $arrowSide == 'bottom' {
            &:before { border-color: color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment)) transparent transparent transparent; }
            &:after, .bubble-body:first-of-type:after { border-color: map-get($s, surfaceBg) transparent transparent transparent; }
        } @else if $arrowSide == 'left' {
            &:before { border-color: transparent color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment)) transparent transparent; }
            &:after, .bubble-body:first-of-type:after { border-color: transparent map-get($s, surfaceBg) transparent transparent; }
        } @else if $arrowSide == 'right' {
            &:before { border-color: transparent transparent transparent color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment)); }
            &:after, .bubble-body:first-of-type:after { border-color: transparent transparent transparent map-get($s, surfaceBg); }
        }

        // When a header is present, make the inner arrow match the header bg
        &.with-header {
            $headerBg: color.adjust(map-get($s, surfaceBg), $lightness: map-get($s, borderLightnessAdjustment));
            @if $arrowSide == 'top' {
                &:after, .bubble-body:first-of-type:after { border-color: transparent transparent $headerBg; }
            } @else if $arrowSide == 'bottom' {
                &:after, .bubble-body:first-of-type:after { border-color: $headerBg transparent transparent transparent; }
            } @else if $arrowSide == 'left' {
                &:after, .bubble-body:first-of-type:after { border-color: transparent $headerBg transparent transparent; }
            } @else if $arrowSide == 'right' {
                &:after, .bubble-body:first-of-type:after { border-color: transparent transparent transparent $headerBg; }
            }
        }
    }
}

// Convenience one-shot mixin for quick setup
// -------------------------------------------
@mixin infoBubble($config: ()) {
    @include infoBubblePlacement($config);
    @include infoBubbleStructure($config);
    @include infoBubbleTheme($config);
}
