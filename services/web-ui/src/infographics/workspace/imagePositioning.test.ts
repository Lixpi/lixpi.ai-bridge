'use strict'

import { describe, it, expect } from 'vitest'
import type { CanvasNode, AiChatThreadCanvasNode, ImageCanvasNode } from '@lixpi/constants'
import { computeImagePositionNextToThread, countExistingImagesForThread } from '$src/infographics/workspace/imagePositioning.ts'

// =============================================================================
// HELPERS
// =============================================================================

function makeThread(overrides: Partial<AiChatThreadCanvasNode> = {}): AiChatThreadCanvasNode {
	return {
		nodeId: 'thread-1',
		type: 'aiChatThread',
		referenceId: 'ref-thread-1',
		position: { x: 100, y: 200 },
		dimensions: { width: 300, height: 600 },
		...overrides,
	}
}

function makeImageNode(overrides: Partial<ImageCanvasNode> & { nodeId: string }): ImageCanvasNode {
	return {
		type: 'image',
		fileId: 'file-1',
		workspaceId: 'ws-1',
		src: 'test.jpg',
		aspectRatio: 1,
		position: { x: 0, y: 0 },
		dimensions: { width: 400, height: 400 },
		generatedBy: {
			aiChatThreadId: 'ref-thread-1',
			responseId: 'resp-1',
			aiModel: 'dall-e-3' as any,
			revisedPrompt: '',
		},
		...overrides,
	}
}

// =============================================================================
// computeImagePositionNextToThread
// =============================================================================

describe('computeImagePositionNextToThread', () => {
	it('places the first image (index 0) aligned with the top of the thread', () => {
		const thread = makeThread({ position: { x: 100, y: 200 }, dimensions: { width: 300, height: 600 } })
		const pos = computeImagePositionNextToThread(thread, 0, 400, 400)

		expect(pos.x).toBe(100 + 300 + 50) // thread.x + thread.width + 50px gap
		expect(pos.y).toBe(200) // same as thread top
	})

	it('places the second image (index 1) below the first with a 30px gap', () => {
		const thread = makeThread({ position: { x: 100, y: 200 }, dimensions: { width: 300, height: 600 } })
		const pos = computeImagePositionNextToThread(thread, 1, 400, 400)

		expect(pos.x).toBe(450)
		expect(pos.y).toBe(200 + 1 * (400 + 30)) // thread.y + 1 * (imageHeight + gap)
	})

	it('places the third image (index 2) further down', () => {
		const thread = makeThread({ position: { x: 100, y: 200 }, dimensions: { width: 300, height: 600 } })
		const pos = computeImagePositionNextToThread(thread, 2, 400, 400)

		expect(pos.x).toBe(450)
		expect(pos.y).toBe(200 + 2 * (400 + 30))
	})

	it('respects different image dimensions', () => {
		const thread = makeThread({ position: { x: 0, y: 0 }, dimensions: { width: 200, height: 400 } })
		const pos = computeImagePositionNextToThread(thread, 1, 300, 250)

		expect(pos.x).toBe(200 + 50) // thread.width + gap
		expect(pos.y).toBe(0 + 1 * (250 + 30)) // imageHeight + gap
	})

	it('handles thread at negative coordinates', () => {
		const thread = makeThread({ position: { x: -500, y: -300 }, dimensions: { width: 300, height: 600 } })
		const pos = computeImagePositionNextToThread(thread, 0, 400, 400)

		expect(pos.x).toBe(-500 + 300 + 50)
		expect(pos.y).toBe(-300)
	})
})

// =============================================================================
// countExistingImagesForThread
// =============================================================================

describe('countExistingImagesForThread', () => {
	it('returns 0 when no images exist', () => {
		const nodes: CanvasNode[] = [
			makeThread(),
		]
		expect(countExistingImagesForThread(nodes, 'ref-thread-1')).toBe(0)
	})

	it('counts images generated by the specified thread', () => {
		const nodes: CanvasNode[] = [
			makeThread(),
			makeImageNode({ nodeId: 'img-1', generatedBy: { aiChatThreadId: 'ref-thread-1', responseId: 'r1', aiModel: 'dall-e-3' as any, revisedPrompt: '' } }),
			makeImageNode({ nodeId: 'img-2', generatedBy: { aiChatThreadId: 'ref-thread-1', responseId: 'r2', aiModel: 'dall-e-3' as any, revisedPrompt: '' } }),
		]
		expect(countExistingImagesForThread(nodes, 'ref-thread-1')).toBe(2)
	})

	it('ignores images from other threads', () => {
		const nodes: CanvasNode[] = [
			makeThread(),
			makeImageNode({ nodeId: 'img-1', generatedBy: { aiChatThreadId: 'ref-thread-1', responseId: 'r1', aiModel: 'dall-e-3' as any, revisedPrompt: '' } }),
			makeImageNode({ nodeId: 'img-2', generatedBy: { aiChatThreadId: 'other-thread', responseId: 'r2', aiModel: 'dall-e-3' as any, revisedPrompt: '' } }),
		]
		expect(countExistingImagesForThread(nodes, 'ref-thread-1')).toBe(1)
	})

	it('ignores non-image nodes', () => {
		const nodes: CanvasNode[] = [
			makeThread(),
			{ nodeId: 'doc-1', type: 'document', referenceId: 'doc-ref', position: { x: 0, y: 0 }, dimensions: { width: 200, height: 100 } } as CanvasNode,
		]
		expect(countExistingImagesForThread(nodes, 'ref-thread-1')).toBe(0)
	})

	it('returns 0 for empty nodes array', () => {
		expect(countExistingImagesForThread([], 'ref-thread-1')).toBe(0)
	})
})
